mod core.string;

import std.abort;
public import core.array;

def opIndex (T) (ref a : string, i : r!(T)) -> [char] {
    if i.scd >= i.fst && (i.scd - i.fst) <= a.len && i.fst <= a.len {
        return [char] {cast!ulong (i.scd - i.fst), a.ptr + i.fst};
    } else {
        abort ();
        return [char] {0UL, null};
    }
}

def opAssign ("=") (const a : [char], const b : string) -> [char] {
    let aux = string {a.len, a.ptr}; // bon la preuve que constant veut pas dire grand chose au final ...
    if a.len != b.len {
        println (("Array lengths don't match for copy: ", a.len, " != ", b.len));
        abort ();
    }

    for it in 0U .. a.len {
        aux [it] = b [it];
    }
    
    return a;
}

def dup (const array : string) -> mut string {
    extern (C) GC_malloc (len : ulong) -> p!char;
    let res = string {array.len, GC_malloc (array.len)};
    for it in 0U .. array.len {
        res [it] = array [it];
    }
    return res;
}

def opEquals (const left : string, const right : string) -> bool {
    if left.len != right.len
        return false;
    
    for it in 0UL .. left.len {
        if left [it] != right [it]
            return false;
    }
    return true;
}

def opTest (op : string) (const left : string, const right : string) -> int {
    let min = left.len;
    if right.len < min {
        min = right.len;
    }
    
    for it in 0U .. min {    
        if left [it] != right [it] {
            if left [it] < right [it]  return -1;
            else return 1;
        }
    }
    
    return 0;
}
