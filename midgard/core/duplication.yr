mod core::duplication;


mod allocMod {T} {
    pub extern (C) def _yrt_new_array (_ : usize, _ : usize)-> dmut [T];
    pub extern (C) def _yrt_new_block (_ : usize, _ : usize)-> dmut &(T);
    pub extern (C) def memcpy (_ : &(T),  _ : &T, _ : usize)-> void;
}

pub def alloc {T} (a : T) -> mut & (mut T) {
    let mut x = alias allocMod!{T}::_yrt_new_block (sizeof T, 1u64)        
    *x = a;
    return x;
}
    
pub def allocBlock {T} (len : usize) -> dmut &T {
    alias allocMod!{T}::_yrt_new_block (sizeof T, len)
}

pub def allocArray {T} (len : usize) -> dmut [T] {
    alias allocMod!{T}::_yrt_new_array (sizeof T, len)
}

/**
 * Copy the second array inside the first one, without reallocation
 * Copy only what can be copied (max (to.len, fr.len))
 */
pub def memCopy {T} (fr : [T], mut to : [mut T]) {
    let len = if (to.len < fr.len) { to.len } else { fr.len }
    allocMod!{T}::memcpy (to.ptr, fr.ptr, len *:usize sizeof (T));
}

pub {

    trait Copiable {
        pub def deepCopy (self)-> dmut (typeof self);
    }

    def deepCopy {T} (a : T)-> mut T {
        a
    }
    
    def deepCopy {struct T} (a : T) -> mut T {
        let dmut t = alias ([0u8 ; sizeof (T)]);
        let aPtr = &a;
        __pragma!trusted ({
            cte for i in 0us .. (__pragma!field_offsets (T)).len {
                let offset = (__pragma!field_offsets (T)) [i];
                let size = sizeof (__pragma!field_type (T, (__pragma!field_names (T))[i]));
                let dmut to : &(mut void) = alias (cast!(&void) ((t [offset .. (offset + size)]).ptr));
                let from : &(void) = cast!(&void) (aPtr + offset);
                *(cast! (mut &(__pragma!field_type (T, (__pragma!field_names (T))[i]))) (to)) = dcopy *(cast! (&(__pragma!field_type (T, (__pragma!field_names (T))[i]))) (from));
            }
        });
        
        alias __pragma!trusted ({
            let dmut j = alias *(cast!(mut &(mut T)) (cast!(mut &(mut void)) (t.ptr)));
            alias j
        })
    }

    def deepCopy {T of [U], U} (a : T) -> dmut [dmut U] {
        let dmut x : dmut [U] = alias allocArray!U (a.len);
        __pragma!trusted ({
            for i in 0us .. a.len {
                x[i] = dcopy a [i];
            }
        });
        alias x
    }
}
