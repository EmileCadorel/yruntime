mod std.range;

def iota (T) (n : T) -> mut [T] {
    let res = [T ; new cast!u64 (n)];
    for i in 0U .. cast!u64 (n)
        res [i] = cast!T (i);
    return res;
}


struct (T)
| source : [T]
| dir : bool
 -> Range;    


def retro (T) (a : [T]) {
    return Range!T {a, true};
}

def copy (T) (a : Range!T, b : [T]) {
    for i in 0U .. b.len {
        if a.dir {
            b [i] = a.source [a.source.len - i - 1U];
        }        
    }
}


