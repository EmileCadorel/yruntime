mod std::list
import std::memory;
import std::io
import std::abort
    
mod inner {
    struct 
    | value : T
    | next : &(Node!(T)) = null
     -> Node (T);
}


pub struct
| head : &(inner::Node!T) = null
 -> List (T);


pub def push (T) (a : List!T, b : T) -> List!T {
    return if (a.head is null) {
        List!T (?head=alloc (inner::Node!T (b)))
    } else
        List!T(?head=pushNode!(T) (a.head, b))
}


def pushNode (T) (a : &(inner::Node!T), b : T) -> &(inner::Node!T) {
    if a is null 
        alloc (inner::Node!T(b))
    else
        alloc (inner::Node!T ((*a).value, ?next=pushNode ((*a).next, b)))    
}


pub def pop (T) (a : List!T) -> (T, List!T) {
    if (a.head is null) {
        abort ();
    }
    
    let (x, y) = popNode!(T) (a.head);
    return (x, List!T (?head=y));
}

def popNode (T) (a : &(inner::Node!T)) -> (T, &(inner::Node!T)) {
    if ((*a).next is null) {
        return ((*a).value, cast!(&(inner::Node!T)) (null))
    }
    
    let (x, y) = popNode ((*a).next);
    (x, alloc (inner::Node!(T) ((*a).value, ?next=y)))        
}


pub def printList (T) (a : List!T) {        
    let mut current = a.head;
    while current !is null {
        print ("[");
        print ((*current).value);
        print ("]::");
        current = (*current).next;
    }
    println ("NIL");
}
