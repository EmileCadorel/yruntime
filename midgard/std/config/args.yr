mod std::config::args;

import core::typeinfo, core::array, core::exception;
import std::conv;
import std::lexer;
import std::config::_;
import std::collection::set;
import std::io;

/**
 * The list of tokens that can be found inside a list of arguments
 * 
 */
enum
| DHYPHEN = " --"
| SHYPHEN = " -"
| EQUALS = "="
| QUOTE = "\""
 -> ArgsTokens;

pub enum
| YES = true
| NO = false
 -> YesNo;

/**
 * Parse a command line arguments according to a structure definition
 * @example: 
 * ================
 * import std::io;
 * 
 * struct
 * | mut help : YesNo
 * | mut h : YesNo
 * | mut create : [c32]
 * | mut v : YesNo
 * -> Options;
 * 
 * def main (args: [[c8]]) {
 *    {
 *      let cfg = args.parse!Options (help-> ["h", "help"]);
 *      if (cfg.h || cfg.help) {
 *         print (usage!Options ());
 *      } 
 *      if (cfg.v) println ("Verbose is active");
 *      println ("Creating file ", name);
 *    } catch {
 *       err: &ConfigCastFailure => {
 *            print (diagnosis (err));
 *            print (usage!Options ());
 *       }
 *    }
 * }
 * ================
 * @info: 
 * =============
 * Accepted types of options arguments are: 
 *    - i32, i64
 *    - bool
 *    - YesNo: set if the field is found in the command line, set to no otherwise
 *    - [c32]
 *    - [T of AcceptedType]
 * The optional parameter help, is used to determine the name of the field that if set (one of them) the structure is returned even if partially initialized without throwing errors
 * =============
 */
pub def parse (struct T) (line : [[c8]], help : [[c32]] = [])-> T
    throws &ConfigCastFailure
{
    let mut c32Line : [c32] = [];
    for i in line {        
        c32Line = c32Line ~ " " ~ i.to!([c32]) ();
    }

    parse!T (c32Line, help-> help)   
}


/**
 * Parse a command line arguments according to a structure definition
 * @example: 
 * ================
 * import std::io;
 * 
 * struct
 * | mut help : YesNo
 * | mut h : YesNo
 * | mut create : [c32]
 * | mut v : YesNo
 * -> Options;
 * 
 * def main () {
 *    {
 *      let cfg = (["./a.out", "--help"]).parse!Options (help-> ["h", "help"]);
 *      if (cfg.h || cfg.help) {
 *         print (usage!Options ());
 *      } else {
 *          if (cfg.v) println ("Verbose is active");
 *          println ("Creating file ", name);
 *      }
 *    } catch {
 *       err: &ConfigCastFailure => {
 *            print (diagnosis (err));
 *            print (usage!Options ());
 *       }
 *    }
 * }
 * ================
 * @info: 
 * =============
 * Accepted types of options arguments are: 
 *    - i32, i64
 *    - bool
 *    - YesNo: set if the field is found in the command line, set to no otherwise
 *    - [c32]
 *    - [T of AcceptedType]
 * The optional parameter help, is used to determine the name of the field that if set (one of them) the structure is returned even if partially initialized without throwing errors
 * =============
 */
pub def parse (struct T) (line : [[c32]], help : [[c32]] = [])-> T
    throws &ConfigCastFailure
{
    let mut res = "";
    for i in line {
        res = res ~ " " ~ i;
    }
    
    parse!T (res, help-> help)
}

/**
 * Parse a command line arguments according to a structure definition
 * @example: 
 * ================
 * import std::io;
 * 
 * struct
 * | mut help : YesNo
 * | mut h : YesNo
 * | mut create : [c32]
 * | mut v : YesNo
 * -> Options;
 * 
 * def main () {
 *    {
 *      let cfg = ("./a.out --help").parse!Options (help-> true);
 *      if (cfg.h || cfg.help) {
 *         print (usage!Options ());
 *      } else {
 *          if (cfg.v) println ("Verbose is active");
 *          println ("Creating file ", name);
 *      }
 *    } catch {
 *       err: &ConfigCastFailure => {
 *            print (diagnosis (err));
 *            print (usage!Options ());
 *       }
 *    }
 * }
 * ================
 * @info: 
 * =============
 * Accepted types of options arguments are: 
 *    - i32, i64
 *    - bool
 *    - YesNo: set if the field is found in the command line, set to no otherwise
 *    - [c32]
 *    - [T of AcceptedType]
 * The optional parameter help, is used to determine the name of the field that if set (one of them) the structure is returned even if partially initialized without throwing errors
 * =============
 */
pub def parse (struct T) (content : [c32], help : [[c32]] = []) -> T
    throws &ConfigCastFailure
{
    let mut res = T::init;
    let dmut lex = Lexer::new (content, tokens-> ArgsTokens::members);
    let dmut used = HashSet!([c32])::new (); 
    let (_, _, _) = lex:.next ();
    loop {
        let (tok, _, _) = lex:.next ();
        if (tok == ArgsTokens::SHYPHEN || tok == ArgsTokens::DHYPHEN) {
            let (name, _, _) = lex:.next ();
            res = parseValues!T (alias lex, name, res);
            used:.insert (name);
        } else if (tok != ArgsTokens::EQUALS && tok != "") {
            res = parseValues!T (alias lex, tok, res);
            used:.insert (tok);
        } else if (tok == ArgsTokens::EQUALS) {
        } else {
            break {}
        }
    }
    
    verifyInit!T (used, res, help)
}

/**
 * Create a string containing a diagnosis for the error
 * @example: 
 * ===============
 * {
 *    let cfg = args.parse!Conf ();
 * } catch {
 *    err: &ConfigCastFailure {
 *         println (err.diagnosis!Conf ());
 *    }
 * }
 * ===============
 */
pub def diagnosis (struct T) (err : &ConfigCastFailure)-> [c32] {
    match (err.subError) {
        Ok (sub: &ConfigCastFailure) => {
            return "Argument type error for '" ~ err.field ~ "' : expected '" ~ usageValue (sub.to) ~ "' not '" ~ usageValue (sub.fr) ~ "'";
        }
        Err (sub: &SyntaxError) => {
            return "Argument type error for '" ~ err.field ~ "' : syntax error (" ~ sub.msg ~ ")";
        }        
    }

    cte for i in 0u32 .. typeof (__pragma!tupleof (__pragma!field_names(T)))::arity {
        if ((__pragma!field_names (T))[i] == err.field)
            return "The argument '" ~ err.field ~ "' is required";
    }

    return "Undefined argument '" ~ err.field ~ "'";
}


/**
 * Create a string containing usage information for filling a structure from command line arguments
 * @example: 
 * ==============
 * struct 
 * | mut h : YesNo
 * | mut foo : i32
 * | mut bar : [c32]
 * | mut baz : [i32] = []
 *  -> Options;
 *
 * let msg = usage!(Options) ();
 * assert (msg == "usage: [--h] --foo int --bar str [--baz [ int... ]]")
 * ==============
 */
pub def usage (struct T) () -> [c32] {
    let mut res = "usage: ";
    cte for i in 0u32 .. typeof (__pragma!tupleof (__pragma!field_names(T)))::arity {
        cte if i != 0u32 res = res ~ " ";
        cte if ((__pragma!has_default (T))[i] || is!(typeof ((__pragma!tupleof (T::init)).i)) (U of YesNo)) {
            cte if is!(typeof ((__pragma!tupleof (T::init)).i)) (U of YesNo) {
                res = res ~ "[--" ~ (__pragma!field_names(T))[i] ~ "]";
            } else {
                res = res ~ "[--" ~ (__pragma!field_names(T))[i] ~ " " ~ usageValue!(typeof ((__pragma!tupleof (T::init)).i)) () ~ "]";
            }
        } else {
            res = res ~ "--" ~ (__pragma!field_names(T))[i] ~ " " ~ usageValue!(typeof ((__pragma!tupleof (T::init)).i)) ();
        }
    }
    res
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def usageValue (t : TypeInfo) -> [c32] {
    if (equals (t, i64::typeinfo)) { return usageValue!i64 (); }
    if (equals (t, i32::typeinfo)) { return usageValue!i32 (); }
    if (equals (t, bool::typeinfo)) { return usageValue!bool (); }
    if (equals (t, f64::typeinfo)) { return usageValue!f64 (); }
    if (equals (t, [c32]::typeinfo)) { return usageValue![c32] (); }
    if (t.inner.len != 0u64)
        return __pragma!trusted ({ "[" ~ usageValue (t.inner [0]) ~ "... ]" });
    else
        return "void";
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def if (is!T (U of i32) || is!T (U of i64)) usageValue (T) () -> [c32] {
    "int"
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def if (! (is!T (U of YesNo))) usageValue (T of bool) () -> [c32] {
    "bool"
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def usageValue (T of [U], U of c32) () -> [c32] {
    "str"
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def usageValue (T of f64) () -> [c32] {
    "float"
}

/**
 * @returns: a string containing the name of the type for usage printing
 */
prv def usageValue (T of [U], U) () -> [c32] {
    "[ " ~ usageValue!U () ~ "... ]"
}

/**
 * Parse a list of values for a given field name
 * @params: 
 *    - lex: the lexer containing the content of the command line
 *    - name: the name of the field the fill
 *    - init: the current state of the structure
 * @throws: 
 *    - &ConfigCastFailure: if the field cannot be filled correctly with what is in the lexer
 */
prv def parseValues (struct T) (dmut lex : &Lexer, name : [c32], init : T)-> T
    throws &ConfigCastFailure
{
    let mut res = init;
    cte for i in 0u32 .. typeof (__pragma!tupleof (res))::arity {
        if ((__pragma!field_names (T))[i] == name) {
            cte if (__pragma!compile ({
                let mut _ : &(mut typeof ((__pragma!tupleof (res)).i)) = alias ((__pragma!field_addrs (res)).i);
            })) {
                cte if (is!typeof ((__pragma!tupleof (res)).i) (U of YesNo)) {
                    let mut x : &(mut typeof ((__pragma!tupleof (res)).i)) = alias ((__pragma!field_addrs (res)).i);
                    *x = parseValue!(typeof(*x)) (alias lex);
                } else {
                    {
                        cte if (__pragma!compile ({
                            parseValue!(typeof ((__pragma!tupleof (res)).i)) (alias lex);
                        })) {
                            let mut x : &(mut typeof ((__pragma!tupleof (res)).i)) = alias ((__pragma!field_addrs (res)).i);
                            *x = parseValue!(typeof(*x)) (alias lex);
                        } else {
                            parseValue!(typeof ((__pragma!tupleof (res)).i)) (alias lex);
                            cte assert (false, "Type '" ~ typeof ((__pragma!tupleof (res)).i)::typeid ~ "' cannot be encoded in an argument parser");
                        }

                    } catch {
                        err : &ConfigCastFailure => {
                            throw ConfigCastFailure::new (name-> (__pragma!field_names (T))[i], T::typeinfo, void::typeinfo, subError-> (cast!(&Exception) (err))?);
                        }
                        _ => {
                            throw ConfigCastFailure::new (name-> (__pragma!field_names (T))[i], T::typeinfo, void::typeinfo);
                        }
                    }
                }
            } else {
                cte assert (false, "Field '" ~ (__pragma!field_names (T))[i] ~ "' of type " ~ T::typeid ~ " must be mutable");
            }
            
            return res;
        }
    }

    throw ConfigCastFailure::new (name-> name, T::typeinfo, void::typeinfo);
} catch {
    err : &ConfigCastFailure => {
        throw err;
    }
    _  => {
        throw ConfigCastFailure::new (T::typeinfo, void::typeinfo);
    }
}

/**
 * Parse an array value in the lexer
 * @info: the returned array can be empty
 */
prv def parseValue (T of [U], U) (dmut lex : &Lexer)-> T
    throws &ConfigCastFailure
{
    import std::collection::vec;
    let dmut res = Vec!(U)::new ();
    loop {
        let (txt, _, _) = lex:.nextNoConsume ();
        match txt {
            ArgsTokens::SHYPHEN => { break {} }
            ArgsTokens::DHYPHEN => { break {} }
            "" => { break {} }
            _ => {
                cte if (is!U (Z of [c32])) {
                    res:.push (parseValue!U (alias lex))
                } else {
                    lex:.next ();
                    res:.push (parseValue!U (txt));
                }
            }
        }
    }
    
    res:.fit ();
    res []
}

/**
 * Parse a int literal in the lexer
 * @throws: 
 *    - &ConfigCastFailure: if the next word in the lexer does not contains a int value
 */
prv def parseValue (T of i64) (dmut lex : &Lexer) -> i64
    throws &ConfigCastFailure
{
    let (txt, _, _) = lex:.next ();
    parseValue!T (txt)
}

/**
 * Parse a int literal in the lexer
 * @throws: 
 *    - &ConfigCastFailure: if the next word in the lexer does not contains a int value
 */
prv def parseValue (T of i32) (dmut lex : &Lexer) -> i32
    throws &ConfigCastFailure
{
    let (txt, _, _) = lex:.next ();
    cast!i32 (parseValue!i64 (txt))
}

/**
 * Try to transform a string into a int value
 * @throws: 
 *    - &ConfigCastFailure: if the string does not contain a int value (nor a hexa decimal value)
 */
prv def parseValue (T of i32) (txt: [c32]) -> i32
    throws &ConfigCastFailure
{
    cast!i32 (parseValue!i64 (txt))
}

/**
 * Try to transform a string into a int value
 * @throws: 
 *    - &ConfigCastFailure: if the string does not contain a int value (nor a hexa decimal value)
 */
prv def parseValue (T of i64) (txt: [c32]) -> i64
    throws &ConfigCastFailure
{
    if (txt == "") {
        throw ConfigCastFailure::new (i64::typeinfo, void::typeinfo);
    }
    
    import std::conv;    
    {
        to!(i64) (txt)
    } catch {
        _ : &CastFailure => {
            cast!i64 (to!(u32, "x") (txt))            
        } catch {
            _ => {
                throw ConfigCastFailure::new (i64::typeinfo, [c32]::typeinfo);
            }
        }
    }    
}

/**
 * @returns: YesNo::YES
 */
prv def parseValue (T of YesNo) (dmut _ : &Lexer)-> YesNo {
    YesNo::YES
}

/**
 * Parse a bool value in a lexer
 * @throws: 
 *    - &ConfigCastFailure: if neither "true" or "false" is found in the next word of the lexer
 */
prv def if (!is!T (U of YesNo)) parseValue (T of bool) (dmut lex : &Lexer) -> bool
    throws &ConfigCastFailure
{
    let (txt, _, _) = lex:.next ();
    parseValue!T (txt)
}

/**
 * Try to transform a string into a bool value
 * @throws: 
 *    - &ConfigCastFailure: if the string is neither equal to "true" or "false" 
 */
prv def if (!is!T (U of YesNo)) parseValue (T of bool) (txt: [c32]) -> bool
    throws &ConfigCastFailure
{
    match txt {
        "true" => { return true }
        "false" => { return false }
        _ => {
            throw ConfigCastFailure::new (bool::typeinfo, [c32]::typeinfo);
        }
    }
}

/**
 * Parse a float value into a lexer
 * @throws: 
 *    - &ConfigCastFailure: if the next word in the lexer does not contains a float value
 */
prv def parseValue (T of f64) (dmut lex : &Lexer) -> f64
    throws &ConfigCastFailure
{
    let (txt, _, _) = lex:.next ();
    parseValue!T (txt)
}

/**
 * Transform a string into a float value
 * @throws: 
 *    - &ConfigCastFailure: if string does not contain a float value
 */
prv def parseValue (T of f64) (txt: [c32]) -> f64
    throws &ConfigCastFailure
{
    if (txt == "") {
        throw ConfigCastFailure::new (i64::typeinfo, void::typeinfo);
    }
    
    import std::conv;    
    {
        to!(f64) (txt)
    } catch {
        _ => {
            throw ConfigCastFailure::new (i64::typeinfo, [c32]::typeinfo);
        }        
    }    
}

/**
 * Parse a string literal in the lexer
 * @throws : 
 *    - &ConfigCastFailure: if the reading of the string failed
 */
prv def parseValue (T of [U], U of c32) (dmut lex : &Lexer)-> [c32]
    throws &ConfigCastFailure
{
    let (txt, _, _) = lex:.nextNoConsume ();
    if (txt == ArgsTokens::QUOTE) {
        parseString (alias lex)        
    } else {
        let (msg, l, c) = lex:.next ();
        if (msg == "") {
            throw SyntaxError::new ("Unterminated string literal", l, c);
        }
        txt
    }
} catch {
    x : _ => throw ConfigCastFailure::new ([c32]::typeinfo, void::typeinfo, subError-> (x)?);
}

/**
 * Parse a string literal in the lexer
 * This function is used to read a string enclosed by quotes
 * @throws : 
 *    - &SyntaxError: if the reading of the string failed
 */
prv def parseString (dmut lex : &Lexer)-> [c32]
    throws &SyntaxError
{
    import std::config::toml;
    
    let mut res = "";

    let (end, line, col) = lex:.next ();
    if (end != "'" && end != "\"") throw SyntaxError::new ("expected '\"' or '\\'' (not '" ~ end ~ "')", line, col);
    println (end,"  ", line, " ", col);
    
    lex:.doSkip (false);
    loop {        
        let (next, l, c) = lex:.next ();
        if (next == "") {
            throw SyntaxError::new ("Unterminated string literal", l, c);
        } else if (next == end) break {}
        
        res = res ~ next;                    
    }
    
    lex:.doSkip (true);
    return res;
}


/**
 * Verify that all mandatory fields, (without default values) are correctly set by the parsing of the command line arguments
 * All YesNo fields are set to false, if they have not been read in the command line
 * @throws : 
 *    - &ConfigCastFailure: if a field has no default value and has not been set
 */
prv def verifyInit (struct T) (used : &HashSet!([c32]), init : T, help : [[c32]])-> T    
    throws &ConfigCastFailure
{
    let mut res = init;
    let mut dont_throw = false;
    for i in help {
        if i in used {
            dont_throw = true;
            break {}
        }
    }
    
    cte for i in 0u32 .. typeof (__pragma!tupleof (res))::arity {
        cte if (!(__pragma!has_default (T))[i]) {
            if ((__pragma!field_names (T))[i] !in used) {
                cte if (is!typeof ((__pragma!tupleof (res)).i) (U of YesNo)) {
                    {
                        used;
                        let mut x : &(mut typeof ((__pragma!tupleof (res)).i)) = alias ((__pragma!field_addrs (res)).i);
                        *x = YesNo::NO;
                    } catch {
                        _ => {                
                            throw ConfigCastFailure::new (name-> (__pragma!field_names (T))[i], typeof ((__pragma!tupleof (res)).i)::typeinfo, void::typeinfo);
                        }
                    }
                } else {
                    if (!dont_throw) {
                        throw ConfigCastFailure::new (name-> (__pragma!field_names (T))[i], typeof ((__pragma!tupleof (res)).i)::typeinfo, void::typeinfo);
                    }
                }
            }
        }
    }
    res
}
