mod std.algorithm.mutation;
import std.traits;

def copy if (isCollection!T && isCollection!U) (T, U) (const a : T, b : U) {
    let i = 0UL;
    while i < a.len && i < b.len {
        b [i] = a [i];
        i++;
    }
}

def copy if (isCollection!T && isCollection!U) (T, U) (const a : T, b : U, len : ulong) {
    let i = 0UL;
    while i < len {
        b [i] = a [i];
        i++;
    } 
}

def fill if (isCollection!T && !isCollection!U) (T, U) (a : T, val : U) {
    for it in a
        it = val;
}

def fill if (isCollection!T && isCollection!U) (T, U) (a : T, val : const U) {
    let j = 0UL;
    for it in a {
        it = val [j];
        j ++;
        j = j % val.len;
    }
}

def generate (T, FUN : fn (u64, u64) -> T) (len : u64) -> mut [T] {
    let a = [T ; len];
    for it in 0UL .. len
        a [it] = FUN (it, len);
    return a;
}

def generate (T, FUN : fn (u64, u64) -> T, N : u64) () -> mut [T ; N] {
    let a = [T ; N];
    for it in 0UL .. N
        a [it] = FUN (it, N);
    return a;
}

def swap (T) (ref a : T, ref b : T) {
    let z = a;
    a = b;
    b = z;
}
