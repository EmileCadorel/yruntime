mod std::algorithm::sorting;
import std::algorithm::mutation;

pub {

    /**
     * Verifies that an array is sorted using a predicate
     * Params : 
     * - a, an array
     * Templates : 
     * - FUN, a function on two elements returning bool
     * - C, an array of U
     * - U, any
     */    
    def isSorted (FUN : fn (U, U) -> bool, C of [U], U) (a : C) -> bool {
        for i in 0_u64 .. (a.len - 1_u64) {
            if !FUN (a [i], a [i + 1_u64]) {
                return false
            }            
        }
        true
    }


    /**
     * Sort an array using a predicate 
     * Params : 
     * - a, an array
     * Templates : 
     * - FN, a binary function that evaluate the order between two element and return a bool
     * - C, an array type
     * - U, any
     */
    def sort (FN : fn (U, U)-> bool, C of [U], U) (a : C) -> mut [mut U] {
        let mut b : [mut U] = copy a;
        inner::sort!FN (ref b);
        alias b
    }
    

}


mod inner {   
    def sort (FUN : fn (U, U)-> bool, U) (ref mut a : [mut U])  {
        if a.len < 2_u64 return {}
        let pivot = a [a.len / 2_u64];
        
        let mut i = 0_u64, mut j = a.len - 1_u64;
        while true {
            
            while (FUN (a [i], pivot)) { i += 1_u64 }
            while (FUN (pivot, a [j])) { j -= 1_u64 }

            if i >= j break {}            

            let temp = a [i];
            a [i] = a [j];
            a [j] = temp;
            i += 1_u64;
            j -= 1_u64;
        }

        inner::sort!FUN (ref (a [0_u64 .. i]));
        inner::sort!FUN (ref (a [i .. a.len]));
    }

}
