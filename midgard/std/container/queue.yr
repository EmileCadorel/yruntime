mod std::container::queue;
import std::io;
import std::traits;
import core::typeinfo, core::duplication;
import std::option;

pub {

    /**
     * A queue is a collection of values, it is implemented as a simple linked list container.
     * Warning : 
     * =======================
     * A list is not thread safe, if it is mutable, if
     * multiple thread try to modify the list at the same time, it
     * could occur data races.
     * =======================
     * Example : 
     * ===========
     * let mut q = Queue!(i32)::new ();
     * for i in 0 .. 4 {
     *     (alias q).insert (i);
     * }
     * println (q); // 0::1::2::3 
     * (alias q).pop ();
     * println (q); // 1::2::3
     * =========== 
     * This is the implementation of a FIFO (First In First Out)
     */
    class @final Queue (T) {

        let mut _head : Node = Empty::new ();
        
        let mut _tail : Node = Empty::new ();

        /** 
         * Create an empty queue
         */
        self () {}
        
        prv self (mut head : Node, mut tail : Node) with
            _head = alias head,
            _tail = alias tail
        {}

        /**
         * Insert an element at the end of the queue
         * Example : 
         * ==============
         * let mut q = Queue!(i32)::new ();
         * for i in 0 .. 4 {
         *     (alias q).insert (i);
         * }
         *
         * println (q);    // 0::1::2::3
         * ==============
         * Complexity : O (1)
         */
        pub def insert (mut self, t : T) {
            match (ref self._tail) {
                Value!(T) (next -> ref mut x : _) => {
                    x = Value!(T)::new (t);
                    self._tail = alias x;
                }
                Empty () => {
                    self._tail = Value!(T)::new (t);
                    self._head = alias self._tail;
                }
            }
        }

        /**
         * Remove the first element of the queue
         * Example : 
         * ==============
         * let mut q = Queue!(i32)::new ();
         * for i in 0 .. 4 {
         *     (alias q).insert (i);
         * }
         *
         * println (q);    // 0::1::2::3
         * (alias q).pop (); 
         * println (q); // 1::2::3
         * ==============
         * Complexity : O (1)
         */
        pub def pop (mut self) {
            match (ref self._head) {
                Value!(T) (next -> ref mut x : _) => {
                    self._head = alias x;
                    match (ref self._head) {
                        Empty () => {
                            self._tail = alias self._head;
                        }
                    }
                }
            }
        }

        /**
         * Returns: the first element of the list
         */
        pub def head (self) -> Option!T {
            match (self._head) {
                Value!(T) (value-> v: _) => {
                    std::option::Some!(T)::new (v)
                } _ => {
                    let o : Option!T = None!(T)::new ();
                    o
                }                    
            }
        }
        
        impl std::io::Printable {
            pub over print (self) {
                print (self._head);                
            }
        }
        
    }
    
}

prv {
    /**
     * This is the internal part of a queue
     * This cannot go outside of this module, and is only used to represent a queue
     * There are two type of node : 
     * - Value (T), where T is a type of value, that is contained by it
     * - Empty, an empty node that end the queue
     * Example : 
     * =============
     * let x : Node = Value!(i32)::new (42);
     * let y : Node = Empty::new ();
     * println (x, " and ", y);
     * =============
     */
    class @abstract Node {
        self () {}

        impl std::io::Printable;

        impl core::duplication::Copiable;
    }

    /**
     * This is a node of a queue containing a value, and pointing to the next element of the queue
     * The content of the queue is immutable
     */
    class Value (T) over Node {

        /**
         * The value contained in the node
         */
        pub let value : T;

        /**
         * Pointer to the next element
         */
        pub let mut next : Node = Empty::new ();

        /**
         * Create a node, with a given value 
         */
        pub self (value : T) with value = value {}

        
        pub self (value : T, mut next : Node) with value = value, next = alias next {}
        
        pub over print (self) {
            cte if (is!(T)(X impl Printable) || isPrimitive!(T))
                print (self.value)
            else
                print ("Node!(", (self.value)::typeinfo.name, ")");
            
            match (self.next) { // print next iif it is a value
                Value!(T) () => {
                    print ("::", self.next);
                }
            }            
        }

        pub over deepCopy (self) -> mut Node {
            Value!(T)::new (self.value, dcopy self.next)
        }
        
    }

    /**
     * This is a empty node, that marks the end of a queue
     */
    class Empty over Node {
        pub self () {}

        pub over print (self) {
            print ("Empty");
        }

        pub over deepCopy (self) -> mut Node {
            alias Empty::new ()
        }
    }

}
