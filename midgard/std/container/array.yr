mod std::container::array;
import std::io;
import std::traits;
import core::typeinfo, core::duplication;
import std::option;
import std::algorithm::comparison;

mod Copy (T) {
    pub extern (C) def memcpy (a : &T, b : &T, len : usize);
}

pub {
    
    /**
     * Arrays are collection that store data in contiguous memory, like normal arrays
     * They are mutable, but you can't modify there inner datas
     * Example : 
     * =============
     * let mut a = Array!(i32)::new ();
     * (alias a).push (12);
     * println (a); // vec:[12]
     * =============
     */
    class Array (T) {        
        /**
         * The value of the array
         */
        let mut _content : [mut T];

        /**
         * The len of the array, different of the _content.len
         * _content.len is the capacity
         */
        let mut _len : usize = 0us; 

        /**
         * Init the array with values
         * The array /init/ is copied, but not deeply
         * Example : 
         * ============
         * let mut a = Array!(i32)::new ([1, 2, 3]);
         * ============
        * Complexity: O (n), with n the size of the array
         */
        self (init : [T])
            with _content = copy init,
            _len = cast!usize (self._content.len)
        {}

        /**
         * New empty array
         * Complexity: O (1)
         */
        self ()
            with _content = [],
                 _len = 0us
        {}

        /**
         * Add an element in the array
         * Warning : 
         * ============
         * this may change the location of the borrowed values
         * Cf : opIndex (self)-> [T] 
         * =============
         * Example : 
         * ============
         * let mut a = Array!(i32)::new ()
         * (alias a).push (12);
         * (alias a).push (30);
         * println (a); // vec:[12, 30]
         * ============
         * Complexity: 
         * =============
         * O (n), with n the size of the array, but in most case, when
         * the capacity of the allocated block is enough large O (1)
         * =============
         */
        def push (mut self, elem : T) {
            if (self._len == self._content.len) {
                (alias self).reallocate ();
            }

            self._content [self._len] = elem;
            self._len += 1us;
        }

        /**
         * Returns : a new array with a new element append at the end
         * It is a dcopy of /self/ 
         * Warning : 
         * ============
         * This function perform a new allocation at each call
         * ============
         * Complexity : O (n), with n the size of the array
         */
        def push (self, elem : T) -> mut Array!T {
            let mut ret = Array!(T)::new ();
            let n_capa = (self._len + 1us);
            let mut aux : [mut T] = alias allocArray!(T) (cast!u64 (n_capa));
            Copy!(T)::memcpy (aux.ptr, self._content.ptr, (self._len) * sizeof T);
            ret._content = alias aux;
            ret._content [self._len] = elem;
            ret._len = (self._len + 1us);
            ret
        }
        
        /**
         * Remove the last element of the array 
         * Example : 
         * ===========
         * let mut a = Array!(i32)::new ();
         * (alias a).push (12);
         * (alias a).push (30);
         * println (a); // vec:[12, 30]
         * (alias a).pop ();
         * println (a); // vec:[12]
         * ===========
         * Complexity : O (1)
         */
        def pop (mut self) {
            if (self._len > 0us) {
                self._len -= 1us;
            }
        }

        /**
         * Returns : a new array with the last element removed
         * It is a dcopy of /self/
         * Complexity : O (n - 1), with n the size of the array 
         */
        def pop (self)-> mut Array!T {
            if (self._len > 0us) {
                let mut ret = Array!(T)::new ();
                let n_capa = (self._len - 1us);
                let mut aux : [mut T] = alias allocArray!(T) (cast!u64 (n_capa));
                Copy!(T)::memcpy (aux.ptr, self._content.ptr, (self._len - 1us) * sizeof T);
                ret._content = alias aux;
                ret._len = (self._len - 1us);
                ret
            } else dcopy self
        }
        
        /**
         * Returns: the value at the index i
         * If the array is smaller than, i or i is < 0, then return None
         * Complexity : O (1)
         */
        def if (isIntegral!Z) opIndex (Z) (self, i : Z) -> Option!(T) {
            if (cast!usize (i) < self._len)
                Some!(T)::new (self._content [i])
            else {
                let n : Option!(T) = None!(T)::new ();
                n
            }
        }        

        /**
         * Returns: a slice of the data contained in the array
         * Warning : 
         * ==============
         * The slice that will be borrowed, can no longer point to the
         * same data as the Array, if modification are made in the Array
         * Example : 
         * ==============
         * let mut a = Array!(i32)::new ();
         * (alias a).push (12);
         * (alias a).push (30);
         * let slc = a [];
         * (alias a).pop ();
         * println (slc); // [12, 30]
         * println (a); // vec:[12]
         * ==============
         * ==============
         * Complexity : O (1)
         */
        def opIndex (self) -> [T] {
            self._content [0us .. self._len]
        }

        /**
         * Returns : the length of the array (the number of values)
         * Complexity : O (1)
         */
        def len (self)-> usize 
            self._len

        /**
         * When performing push, and pop operation, the size of the array change 
         * To provide a fast insertion and deletion, the allocation
         * size of the array is bigger than the data it contains
         * This function, will make the array allocation block be of the minimal required size
         * Complexity : O (n), with n the size of the array (or O (1), if the array was already fit)
         */
        def fit (mut self) {
            import std::memory;
            if (self._len != self._content.len && self._len != 0us) {
                let n_capa = self._len;
                let mut aux : [mut T] = alias allocArray!(T) (cast!u64 (n_capa));
                Copy!(T)::memcpy (aux.ptr, self._content.ptr, self._len * sizeof T);
                self._content = alias aux;
            }
        }
        
        /**
         * Cf : fit (mut self)
         * Returns : A new Array, that has a fit size
         * Complexity : O (n), with n the size of the array
         */
        def fit (self) -> mut Array!(T) {
            import std::memory;
            let mut ret = Array!(T)::new ();
            if (self._len != self._content.len && self._len != 0us) {
                let n_capa = self._len;
                let mut aux : [mut T] = alias allocArray!(T) (cast!u64 (n_capa));
                Copy!(T)::memcpy (aux.ptr, self._content.ptr, self._len * sizeof T);
                ret._content = alias aux;
                ret._len = self._len;
            }
            ret
        }

        /**
         * Arrays are printable
         * The format is the same as standard arrays, but with the name vec: at the beginning
         * Complexity : O (n), with n the size of the array
         */
        impl std::io::Printable {
            over print (self) {
                print ("vec:[")
                for i in 0us .. self._len {
                    if (i != 0us) print (", ");
                    print (self._content [i]);
                }
                print ("]");
            }
        }

        impl core::duplication::Copiable {
            over deepCopy (self) -> mut Array!T {
                self.fit ()
            }
        }        

        /**
         * Change the allocation block of the array, to have some place to add datas
         * The size of the new allocated block will be two times the the previous size (or 2, if it was empty)
         * Complexity : O (n), with n the size of the array
         */
        prv def reallocate (mut self) {
            import std::memory;
            
            let n_capa = if (self._len != 0us) self._len * 2us else 2us;
            // We use this allocation, instead of the one provided by the language, it is faster, because it does not make a memcpy at initialisation
            // Values are not initialised, but we are doing that just after, so no problem
            let mut aux : [mut T] = alias allocArray!(T) (cast!u64 (n_capa));
            if (self._len != 0us) 
                Copy!(T)::memcpy (aux.ptr, self._content.ptr, self._len * sizeof T);
            self._content = alias aux;
        }
    }


}
