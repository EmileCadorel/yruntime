mod std::container::set;
import std::io;
import std::traits;
import core::typeinfo, core::duplication;
import std::option;
import std::algorithm::comparison;

pub {

    /**
     * A set is a collection of values, that are stored in a tree
     * Each value could appear only once in the set
     * The set is sorted
     * ===========
     * A set is not thread safe, if it is mutable, if
     * multiple thread try to modify the set at the same time, it
     * could occur data races.
     * ===========
     * Example : 
     * ===========
     * let mut s = Set!(i32)::new ();
     * (alias s).insert ("
     * ===========
     */
    class @final Set (T) {

        let mut _head : Node = Empty::new ();
        
        /**
         * A new empty set
         */
        self () {}

        /** Used for deep copy */
        prv self (mut head : Node) with _head = alias head {}
        
        /**
         * Insert a new element in the set
         * Example : 
         * ===========
         * let mut m = Set!(i32)::new ();
         * (alias m).insert (12);
         * println (m); // {12}
         * ===========
         * Complexity : O (h), where h is the height of the tree
         */
        pub def insert (mut self, v : T) {
            self._head = alias ((alias self).insert (alias self._head, v));
        }

        /**
         * Insert a new element in the map, or replace it if it already exists
         * Complexity : O(h), where h is the height of the tree
         */
        prv def insert (self, mut head : Node, v : T) -> mut Node {
            match (ref head) {
                Empty () => {
                    return Value!(T)::new (v);
                }
                Value!(T) (value-> value : _, left-> ref mut left : _, right-> ref mut right : _) => {
                    if (value > v) {
                        left = alias (self.insert (alias left, v));
                    } else if (value < v) {
                        right = alias (self.insert (alias right, v));
                    } else {
                        return alias (Value!(T)::new (v, alias left, alias right));
                    }
                    
                    head.height = max (left.height, right.height) + 1us;                    
                    let balance = left.height -:i64 right.height;
                    
                    let l_value = match (left) { Value!(T) (value-> x : _) => { x } _ => v }
                    let r_value = match (right) { Value!(T) (value-> x : _) => { x } _ => v }
                    
                    if (balance > 1 && v < l_value)
                        return alias (self.rightRotate (alias head));

                    if (balance > 1 && v > l_value) {
                        left = alias self.leftRotate (alias left);
                        return alias self.rightRotate (alias head);
                    }

                    if (balance < -1 && v > r_value) {
                        return alias (self.leftRotate (alias head));
                    }
                    
                    if (balance < -1 && v < r_value) {
                        right = alias self.rightRotate (alias right);
                        return alias self.rightRotate (alias head);
                    }
                }
            }
            return alias head;
        }

        /**
         * Perform a left rotation on a node to balance the tree
         * Complexity : O (1)
         */
        prv def leftRotate (self, mut node : Node) -> mut Node {
            match (ref node) {
                mut x : Value!(T) = Value!(T) (right-> mut y : Value!(T)) => {
                    let mut T2 = alias y.left;
                    y.left = alias node;                            
                    x.right = alias T2;
                    
                    y.height = 1us + max (y.left.height, y.right.height);
                    x.height = 1us + max (x.left.height, x.right.height);
                    
                    return alias y;                                       
                }                
            }

            return alias node;
        }

        /**
         * Perform a right rotation on a node to balance the tree
         * Complexity : O (1)
         */
        prv def rightRotate (self, mut node : Node) -> mut Node {
            match (ref node) {
                mut x : Value!(T) => {
                    match (ref x.left) {
                        mut y : Value!(T) => {
                            
                            let mut T2 = alias y.right;
                            y.right = alias node;
                            x.left = alias T2;

                            y.height = 1us + max (y.left.height, y.right.height);
                            x.height = 1us + max (x.left.height, x.right.height);
                            
                            return alias y;       
                        }
                    }
                }                
            }
            return alias node;
        }


        /**
         * Returns : true, if the set contains the value /v/, and false otherwise
         */
        pub def opContain (self, v : T) -> bool {
            self.find (self._head, v)
        }

        /**
         * Returns : true, if the set contains the value /v/, and false otherwise
         * Complexity : O (h), where h is the height of the tree
         */
        prv def find (self, head : Node, v : T) -> bool {
            match (head) {
                Value!(T) (value-> value : _, left-> l : _, right-> r : _) => {
                    if (v == value) true
                    else if (v < value) self.find (l, v)
                    else self.find (r, v)
                }
                _ => {
                    false
                }
            }
        }


        impl std::io::Printable {
            pub over print (self) {
                print ("{", self._head, "}");
            }
        }
        
    }
    

}


pub {

    /**
     * This is the internal part of a set
     * This cannot go outside of this module, and is only used to represent a set
     * There are two type of nodes : 
     * - Value (V), where V is a type of Value
     * - Empty, an empty node
     */
    class @abstract Node {

        /**
         * The height of the node = 1 + max (height (left), height (right))
         */
        pub let mut height : usize = 0us;
        
        self () {}
        
        impl std::io::Printable;

        impl core::duplication::Copiable;
    }

    /**
     * This is a node of a list containing a value, and pointing to the next element of the list
     * The content of the list is immutable
     */
    class Value (V) over Node {

        /**
         * The value contained in the node
         */
        pub let value : V;
        
        /**
         * Pointer to the left element
         */
        pub let mut left : Node = Empty::new ();

        /**
         * Pointer to the right element
         */
        pub let mut right : Node = Empty::new ();
        
        /**
         * Create a node, with a given value 
         */
        pub self (value : V) with value = value {
            self.height = 0us;
        }

        
        pub self (value : V, mut left : Node, mut right : Node) with
            value = value,
            left = alias left,
            right = alias right
        {
            import std::algorithm::comparison;
            self.height = 1us + max (self.left.height, self.right.height)
        }

        pub over print (self) {            
            match (self.left) {
                l : Value!(V) =>
                    print (l, ", ");
            }            
            
            cte if (is!(V)(X impl Printable) || isPrimitive!(V))
                print (self.value)
            else
                print ((self.value)::typeinfo.name);

            match (self.right) {
                r : Value!(V) =>
                    print (", ", r);                
            }
        }                

        pub over deepCopy (self) -> mut Node {
            Value!(V)::new (self.value, dcopy self.left, dcopy self.right)
        }
        
    }

    /**
     * This is a empty node, that marks the end of a list
     */
    class Empty over Node {
        pub self () {}

        pub over print (self) {}

        pub over deepCopy (self) -> mut Node {
            alias Empty::new ()
        }
    }

}
