mod std::io;

import core::exception, core::typeinfo, core::array;
import core::object;

/**
 * Put a simple ascii char on stdout
 */
extern (C) def putchar (c : c8);

/**
 * Runtime function that write a c32 char on stdout
 */
extern (C) def _yrt_putwchar (c : c32);

/**
 * Runtime function that read a c32 char from stdin
 */
extern (C) def _yrt_getwchar ()-> c32;

/**
 * C printf function 
 */
extern (C) def printf (c : &c8, ...);

/**
 * C scanf function
 */
extern (C) def scanf (c : &c8, ...);

/**
 * Runtime function that prints a f32 to stdout
 */
extern (C) def _yrt_printf32 (f : f32);

/**
 * Runtime function that prints a f64 to stdout
 */
extern (C) def _yrt_printf64 (f : f64);

/**
 * This trait is to be implemented by class
 * When a class implement it, we can call the function print on it
 * @example: 
 * ====================
 * class X {
 * // ...
 * impl std::io::Printable;
 * }
 *
 * let a = X::new ();
 * println ("Test on : ", a); 
 * ====================
 * @warning: 
 * ===========
 * Printable print function prints static typeinfo
 * Which means that for the following example: 
 * @example: 
 * ===========
 * mod main;
 * 
 * class Foo {
 *     pub self () {}
 *     
 *     impl std::io::Printable;
 * }
 * 
 * class Bar over Foo {
 *    pub self () {}
 * }
 * 
 * def main () {
 *     let x = Bar::new ();
 *     println (x);
 * }
 * ===========
 * The result will be : 
 * @example: 
 * ============
 * main::Foo ()
 * ============
 * Because, main::Bar does not reimplement Printable, so the definition of main::Foo is used
 * ===========
 */
pub trait Printable {

    /**
     * Print the content of the class on stdout
     * @returns: true if something has been printed, false otherwise    
     */
    prot def __stdio__printContent (self) -> bool {
        cte if (__pragma!compile ({self::super.__stdio__printContent ();})) {
            let printed = self::super.__stdio__printContent ();
            if (typeof (__pragma!local_tupleof (self))::arity != 0u32 && printed)
                print (", ");
        }
        
        cte if (typeof (__pragma!local_tupleof (self))::arity != 0u32) {
            let mut j = 0;
            for i in __pragma!local_tupleof (self) {
                if (j != 0) print (", ");
                cte if (__pragma!compile ({print (i);})) {
                    print (i);
                } else {
                    print (typeof (i)::typeid);
                }
                j += 1;
            }
        }
        
        cte (typeof (__pragma!local_tupleof (self))::arity != 0u32)
    }

    /**
     * Print the class name and content to stdout
     */
    pub def print (self)-> void {
        print (typeof (self)::typeid, '(');
        self.__stdio__printContent ();
        print (')');
    }
}

pub {
    /**
     * Print a char of size 8 in stdout
     * @params : 
     * - c: the char to print
     */
    def print (c : c8) -> void
        putchar (c)

    /**
     * Print a char of size 32 in stdout
     * @params : 
     * - c: the char to print
     */
    def print (c : c32) -> void
        _yrt_putwchar (c)

    /**
     * Print an array of c32 in stdout
     * @params : 
     * - s: the string to print
     */
    def print (s : [c32]) -> void {
        let mut i = 0_u64;
        while i < s.len {
            print (s [i]);
            i = i + 1_u64;
        }
    } catch { _ => {
    }}
    
    /**
     * Print an array of c8 in stdout
     * @params : 
     * - s: the string to print
     */
    def print (s : [c8]) -> void {
        let mut i = 0_u64;
        while i < s.len {
            print (s [i]);
            i = i + 1_u64;
        }
    } catch { _ => {}}
    
    /**
     * Print a isize to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : isize) -> void
        printf ((alias "%ld"s8).ptr, i)

    /**
     * Print a usize to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : usize) -> void
        printf ((alias "%ld"s8).ptr, i)
    
    /**
     * Print a i64 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : i64) -> void
        printf ((alias "%ld"s8).ptr, i)

    /**
     * Print a i32 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : i32) -> void
        printf ((alias "%d"s8).ptr, i)

    /**
     * Print a i16 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : i16) -> void
        printf ((alias "%hd"s8).ptr, i)

    /**
     * Print a i8 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : i8) -> void
        printf ((alias "%hhx"s8).ptr, i)

    /**
     * Print a u64 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : u64) -> void
        printf ((alias "%lu"s8).ptr, i)
        
    /**
     * Print a u32 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : u32) -> void
        printf ((alias "%u"s8).ptr, i)

    /**
     * Print a u16 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : u16) -> void
        printf ((alias "%hu"s8).ptr, i)

    /** 
     * Print a u8 to stdout
     * @params:
     *    - i: the int to print
     */
    def print (i : u8) -> void
        printf ((alias "%hhx"s8).ptr, i)
        

    /**
     * Print an address to stdout
     * @params: 
     *    - i: the address to print
     */
    def print (i : &(void))-> void
        printf ((alias "%x"s8).ptr, i)
        
    /**
     * Print a float value of size 64 to stdout
     * @params:
     *    - f: the float to print
     */
    def print (f : f64) -> void {
        _yrt_printf64 (f);
    }
        
    /**
     * Print a float value of size 32 to stdout
     * @params:
     *    - f: the float to print
     */
    def print (f : f32) -> void {
        _yrt_printf32 (f);
    }       

    /**
     * Print a bool value to stdout
     * @params:
     *    - b: the bool to print
     */
    def print (b : bool) -> void {
        if (b) 
            printf ((alias "true"s8).ptr)
        else
            printf ((alias "false"s8).ptr)
    }

    /**
     * Print an array of type U to stdout
     * @params:
     *    - a: an array to print
     * @templates : 
     *    - T: a slice type
     *    - U: any 
     */
    def print {T of [U], U} (a : T) -> void {
        let mut i = 0_u64;
        print ('['c8);
        while i < a.len {
            if i != 0_u64
                printf ((alias ", "s8).ptr);
            
            print (a [i]);
            i = i + 1_u64;
        }
        print (']'c8);
    } catch { _ => {}}

    /**
     * Print a static array of type U to stdout
     * @params : 
     *    - a: an array to print
     * @templates : 
     *    - T: an static array type 
     *    - U: any
     *    - N: the static size 
     */
    def print {T of [U;N], U, N : usize} (a : T) -> void {
        print ('['c8);
        for i in 0_u64 .. cast!u64 (N) {
            if i != 0_u64
                printf ((", "s8).ptr);
            print (a [i]);
        }
        print (']'c8);
    } catch {
        _ => {
            // Don't do anything it is impossible to get there
        }
    }

    /**
     * Print an option type to stdout
     * @params: 
     *   - a: a value of type option 
     * @templates: 
     *   - T: any type
     */
    def print {T} (a : T?) -> void {
        match a {
            Ok  (x:_)   => print ("Ok(", x, ")");
            Err (msg:_) => print ("Err(", msg, ")");
            Err ()      => print ("Err()");
        }
    }
    
    /**
     * Print multiple elements to stdout
     */
    def print  {F, T...} (a : F, b : T) {
        print (a);
        cte if (is!T {Z of (U,), U...}) {
            for i in b 
                print (i);
        } else {
            print (b);
        }
    }

    /**
     * Print an element of type tuple to stdout
     * @params: 
     *    - a: a tuple of arbitrary arity
     */
    def print {T of (U,), U...} (a : T) {
        print ('(');
        let mut j = 0;
        for i in a {
            if j != 0 {
                print (',');
            }
            print (i);
            j += 1;
        }        
        if (j == 1) print (',');
        print (')');
    }

    def print (_ : ()) {
        print ('('c8,')'c8);
    }

    def print () {}
    
    /**
     * Print a struct to stdout
     */
    def print {struct T} (a : T) -> void {
        print (T::typeid, "(");
        cte if (typeof (__pragma!tupleof (a))::arity > 0us) {
            let mut j = 0;
            for i in __pragma!tupleof (a) {
                if (j != 0) print (", ");
                print (i);
                j += 1;
            }
        }
        print (")");
    }

    /**
     * Print a class that implement the trait Printable to stdout
     */
    def print {T impl Printable} (a : T)-> void {
        a.print ();
    }

    /**
     * Print the typeid of a object
     */
    def print (a : &Object) -> void {
        print (a::typeinfo.name);
    }
    

    /**
     * Print an arbitrary number of element on stdout, and add a return line afterwards
     */
    def println {T...} (a : T) {
        cte if (is!T {Z of (U,), U...}) {
            for i in a 
                print (i);
        } else {
            print (a);
        }
        
        print ('\n'c8);
    }
    
    /**
     * Read a i32 from the stdin
     * @returns : a i32
     */
    def read {T of i32} () -> i32 {
        let mut x : i32 = 0;
        scanf ("%d"s8.ptr, &x);
        x
    }

    /**
     * Read a u64 from the stdin
     * @returns : a u64
     */
    def read {T of u64} () -> u64 {
        let mut x : u64 = 0_u64;
        scanf ("%ld"s8.ptr, &x);
        x
    }

    /**
     * Read a c8 from the stdin
     * @returns : a c8
     */
    def read {T of c8} () -> c8 {
        let mut x : c8 = '\u{0}'c8;
        scanf ("%c"s8.ptr, &x);
        x
    }

    /**
     * Read a c8 from the stdin, and return it as a c32
     * @returns : a c32
     */
    def read {T of c32} () -> c32 {
        _yrt_getwchar ()       
    }    
    
}
