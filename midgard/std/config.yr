mod std::config;

import core::object, core::typeinfo, core::exception;
import core::array;

import std::io;
import std::collection::vec;
import std::collection::map;


pub class ConfigCastFailure over core::exception::Exception {


    let _name : [c32];
    
    /// The type from which we want a cast    
    let _fr : TypeInfo;

    /// The type to which we want a cast
    let _to : TypeInfo;

    let _subError : (&Exception)?;
    
    /**
     * @params: 
     *    - from, the type from which we want a cast
     *    - to, the type to which we want a cast
     */
    pub self (name : [c32] = "", to : TypeInfo, from : TypeInfo, subError : (&Exception)? = ((&Exception)?)::__err__) with _fr = from, _to = to, _name = name, _subError = subError  {}

    impl std::io::Printable {

        /**
         * Just print the error to stdout
         */
        pub over print (self) {
            print (self::typeinfo.name, ' ', '(');
            print (self._fr.name, "-> ", self._to.name);
            print (')');
            if (self._name != "")
                print (" for field : ", self._name);
            
            match self._subError {
                Ok (x:_) => {
                    println (" => ");
                    print ("\t", x);
                }
                Err () => {
                    println (":");
                    self::super.printStackTrace ();
                }
            }
        }
        
    }
    
}    

/**
 * A configuration file is composed of nodes
 * Each node contains a different type of information
 */
pub class @abstract Config {

    prot self () {}

    pub def opIndex (self, i : i32) -> &Config
        throws &OutOfArray
    {
        if i >= 0
            self.opIndex (cast!u64 (i))
        else {
            throw OutOfArray::new ();
        }
    }

    pub def opIndex (self, _ : u64)-> &Config
        throws &OutOfArray
    {
        throw OutOfArray::new ();
    }
    
    pub def opIndex (self, _ : [c32])-> &Config
        throws &OutOfArray
    {
        throw OutOfArray::new ();
    }

    pub def opIndexAssign (mut self, _ : u64, _ : &Config)-> void
        throws &OutOfArray
    {
        throw OutOfArray::new ();
    }
    
    pub def opIndexAssign (mut self, _ : [c32], _ : &Config)-> void
        throws &OutOfArray
    {
        throw OutOfArray::new ();
    }

    pub def opContains (self, _ : [c32])-> bool {
        false
    }

    /**
     * Try to transform the configuration into a structure
     * @example: 
     * ============
     * import std::config::args;
     *
     * struct 
     * | foo : i64
     * | bar : f64 
     *  -> X;

     * let opt = "./a.out --foo 12 --bar 34.23"
     * let cfg = parse (opt);
     * let x = cfg.to!(X) ();
     * assert (x.foo == 12 && x.bar == 34.23);
     * ============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (struct T) (self) -> T
        throws &ConfigCastFailure
    {
        match self {
            x : &Dict => {
                return x.toStruct!(T) ();
            }
            _ =>
                throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
        }
    }

    /**
     * Transform a configuration into a i64
     * @example: 
     * =============
     * let i = Int::new (12);
     * assert (i.to!(i64) () == 12);
     * =============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (T of i64) (self)-> T
        throws &ConfigCastFailure
    {
        match self {
            Int (i-> i:_) => { return i; }
            _ => {
                throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a f64
     * @example: 
     * =============
     * let i = Float::new (12.0);
     * assert (i.to!(f64) () == 12.0);
     * =============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (T of f64) (self)-> T
        throws &ConfigCastFailure
    {
        match self {
            Float (f-> f:_) => { return f; }
            _ => {
                throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a string
     * @example: 
     * =============
     * let i = Str::new ("foo");
     * assert (i.to!([c32]) () == "foo");
     * =============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (T of [U], U of c32) (self)-> T
        throws &ConfigCastFailure
    {
        match self {
            Str (str-> str:_) => { return str; }
            _ => {
                throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a bool
     * @example: 
     * =============
     * let i = Bool::new (false);
     * assert (i.to!(bool) () == false);
     * =============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (T of bool) (self)-> T
        throws &ConfigCastFailure
    {
        match self {
            Bool (b-> b:_) => { return b; }
            _ => {
                throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into an array
     * @example: 
     * =============
     * let i = Array::new (Int::new (1), Int::new (2));
     * assert (i.to!([i32]) () == [1, 2]);
     * =============
     * @throws: 
     *   - &ConfigCastFailure: if the cast cannot be made
     */
    pub def to (T of [U], U) (self)-> T
        throws &ConfigCastFailure
    {
        match self {
            x : &Array => { return x.toArray!(T) (); }
            _ => {
                cte if (is!(U)(Z of c32)) {
                    match self {
                        Str (str-> str:_) => { return str; }
                    }
                } else {
                    return [self.to!(U) ()];
                }
            }
        }
    }

    
    impl std::io::Printable;
    
}

/**
 * An array is a list of nodes
 * It has the same properties as a Vec!(&Config)
 * @example: 
 * ===============
 * let dmut array = Array::new ();
 * array:.push (Str::new ("foo"));
 * array:.push (Int::new (42));
 * ===============
 */
pub class @final Array over Config {

    let dmut _content = Vec!(&Config)::new ();

    /**
     * Creates a new Array of nodes, containing a pre constructed list of Configs
     * @params: 
     *    - nodes: some nodes to put in the array     
     */
    pub self (nodes : [&Config]) {
        for i in nodes
            self._content:.push (i);
    }

    /**
     * Creates a new empty Array
     */
    pub self () {}


    /**
     * Add a node at the end of the Array
     * @example: 
     * ==============
     * let dmut array = Array::new ();
     * array:.push (Int::new (1));
     * array:.push (Int::new (2));
     * match array [$ - 1u64] {// access the last element of the array
     *    Int(x:_) => assert (x == 2);
     * }
     * ==============
     */
    pub def push (mut self, node : &Config) -> void {
        self._content:.push (node);
    }
    
    /**
     * Access an element at a given Index in the array
     * @throws: 
     *   - &OutOfArray: if the index is not in the array
     * @example: 
     * =================
     * let i : &Config = Int::new (12);
     * let j : &Config = Int::new (42);
     * let dmut array = Array::new ([i, j]);
     * {
     *     match array [0] {
     *         Int (x:_)  => println ("index 0 contains : ", x);
     *     }
     * } catch {
     *    _: &OutOfArray => println ("Array does not contain elements");
     * }
     * =================
     */
    pub over opIndex (self, i : u64) -> &Config
        throws &OutOfArray
    {
        self._content[i]
    }

    /**
     * Change the element at index i
     * throws: 
     *   - &OutOfArray: if i is not a valid index of the array
     * @example: 
     * ===========
     * let i : &Config = Int::new (12);
     * let j : &Config = Int::new (42);
     * let dmut array = Array::new ([i]);
     * {
     *    (alias array) [0] = j;
     * } catch {
     *    _: &OutOfArray => println ("Array does not contain elements");
     * }
     */
    pub over opIndexAssign (mut self, i : u64, node : &Config) -> void
        throws &OutOfArray
    {
        (alias self._content) [i] = node
    }

    /**
     * An alias to get the length of the array
     * @example: 
     * ===========
     * let i : &Config = Int::new (12);
     * let j : &Config = Int::new (42);
     * let dmut array = Array::new ([i, j]);
     * {
     *    // print the last element of the array
     *    println (array [$ - 1u64]);
     * } catch {
     *    _: &OutOfArray => println ("Array does not contain elements");
     * }
     * ===========
     */
    pub def opDollar (self) -> u64 {
        self._content.len ()
    }

    /**
     * @returns: the number of element contained in the array
     * @example: 
     * ==================
     * let i : &Config = Int::new (12);
     * let j : &Config = Int::new (42);
     * let dmut array = Array::new ([i, j]);
     * assert (array.len () == 2u64);
     * ==================
     */
    pub def len (self) -> u64 {
        self._content.len ()
    }

    /**
     * Used to iterate over the array, (similar iteration as Vec!(&Config)).
     * @example: 
     * =============
     * let a : &Config = Int::new (12);
     * let b : &Config = Int::new (42);
     * let dmut array = Array::new ([a, b]);
     * for i, j in array {
     *     println ("At ", j, " => ", i); // At 0 => Ok (Int (12)), At 1 => Ok (Int (42))
     * }
     * =============
     */
    pub def begin (self) -> dmut &VecIterator!(&Config) {
        alias self._content.begin ()
    }

    /**
     * Used to iterate over the array, (similar iteration as Vec!(&Config))
     * @cf: begin
     */
    pub def end (self) -> &VecIterator!(&Config) {
        self._content.end ()
    }

    pub def toArray (T of [U], U) (self) -> T
        throws &ConfigCastFailure
    {
        let dmut res = Vec!(U)::new ();
        for i in self._content {
            match i {
                Ok (cfg: &Config) =>  {
                    res:.push (cfg.to!(U) ());
                }
            }                    
        }
        
        res:.fit ();
        return res [];
    }

    impl std::io::Printable {

        /**
         * Arrays are printable
         */
        pub over print (self) -> void {
            print ("Array (");
            for i, j in self._content {
                if j != 0u64 print (", ");
                match i {
                    Ok (x:_) => print (x);
                }
            }
            print (")");
        }
    }
}

/**
 * A dictionnary associates to values to string keys
 * It has the same properties as HashMap!([c32], &Config)
 * @example: 
 * ============
 * let dmut dict = Dict::new ();
 * dict:.insert ("foo", Str::new ("foo"));
 * dict:.insert ("bar", Int::new (42));
 * dict:.insert ("baz", Array::new ());
 * ============
 */
pub class @final Dict over Config {

    let dmut _content = HashMap!([c32], &Config)::new ();

    /**
     * Creates a new empty dictionnary
     */
    pub self () {}

    /**
     * Insert a new value in the dict
     * @info: if the key was already in the dict, its old value is replaced by the new one
     * @params: 
     *    - k: the index key 
     *    - value: the value to insert
     * @example: 
     * =============
     * let dmut dict = Dict::new ();
     * dict:.insert ("foo", Str::new ("foo"));
     * dict:.insert ("foo", Int::new (42));
     * println (dict); // Dict (foo=> Int (42))
     * =============
     */
    pub def insert (mut self, k : [c32], value : &Config)-> void {
        self._content:.insert (k, value);
    }

    /**
     * Access the element at index k
     * @throws: 
     *    - &OutOfArray: if the index is not found in the dictionnary
     * @params: 
     *    - k: a key index
     * @example: 
     * ================
     * let dmut dict = Dict::new ();
     * dict:.insert ("foo", Str::new ("foo"););
     * dict:.insert ("bar", Int::new (42));
     * {
     *     println (dict["foo"]);
     * } catch {
     *     _ : &OutOfArray => {
     *         println ("foo not found in ", dict);
     *     }
     * }
     * 
     * println (dict["bar"]?); // put it in an option type
     * ================
     */
    pub over opIndex (self, k : [c32])-> &Config
        throws &OutOfArray
    {
        self._content [k]
    }

    /**
     * Change the value at index k 
     * @info: if the value was not in the dictionnary it is inserted
     * @params: 
     *    - k: a index key
     *    - value: the value to insert
     * @example: 
     * ==============
     * let dmut dict = Dict::new ();
     * (alias dict) ["foo"] = Str::new ("foo");    
     * (alias dict) ["bar"] = Int::new (42);
     * 
     * // replace the value at foo index
     * (alias dict) ["foo"] = Int::new (12);
     * ==============
     */
    pub over opIndexAssign (mut self, k : [c32], value : &Config) -> void {
        self._content:.insert (k, value);
    }

    /**
     * Check if a key can be found in the dictionnary 
     * @params: 
     *   - k: the key to find
     * @example: 
     * =================
     * let dmut dict = Dict::new ();
     * (alias dict) ["foo"] = Str::new ("foo");    
     * (alias dict) ["bar"] = Int::new (42);
     * 
     * assert ("foo" in dict);     
     * =================    
     */
    pub over opContains (self, k : [c32])-> bool {
        k in self._content
    }

    /**
     * Used to iterate over the dictionnary
     * @example: 
     * ==============
     * let dmut dict = Dict::new ();
     * (alias dict) ["foo"] = Str::new ("foo");    
     * (alias dict) ["bar"] = Int::new (42);
     * for i, j in dict {
     *     println ("At ", i " => ", j); // At Ok(foo) => Ok (Str (foo)), At Ok (bar) => Ok (Int (42))
     * }
     * ==============
     */
    pub def begin (self) -> dmut &MapIterator!([c32], &Config) {
        alias self._content.begin ()
    }

    /**
     * Used to iterate over the dictionnary
     * @cf: begin
     */
    pub def end (self) -> &MapIterator!([c32], &Config) {
        self._content.end ()
    }

    /**
     * Transform the dictionnary into a struct
     * @example: 
     * ============ 
     * import std::config::args;
     *
     * struct 
     * | foo : i64
     * | bar : f64 
     *  -> X;

     * let opt = "./a.out --foo 12 --bar 34.23"
     * let cfg = parse (opt);
     * let x = cfg.to!(X) ();
     * assert (x.foo == 12 && x.bar == 34.23);
     * ============ 
     * @throws: 
     *   - &ConfigCastFailure: if the configuration does not contains every field of the struct
     * @info: if the configuration contains more information they are ignored
     */
    pub def toStruct (struct T) (self)-> T
        throws &ConfigCastFailure
    {
        let mut t = T::init;
        let mut j = 0;
        let names = T::fields_name;
        
        for ref mut f in t::fields_address {
            let name = names [j];
            if (name in self) {
                {
                    (*f) = self [name].to!(typeof (*f)) ();
                } catch {
                    x : &ConfigCastFailure => {
                        throw ConfigCastFailure::new (name-> name, T::typeinfo, self::typeinfo, subError-> (cast!(&Exception) (x))?);
                    }
                    _ => {
                        throw ConfigCastFailure::new (name-> name, T::typeinfo, self::typeinfo);
                    }
                }
            } else {
                throw ConfigCastFailure::new (name-> name, T::typeinfo, None::typeinfo);
            }
            j += 1;
        }
        
        return t;
    } catch {
        x : &ConfigCastFailure => {
            throw x;
        }
        _  => {
            throw ConfigCastFailure::new (T::typeinfo, self::typeinfo);
        }
    }
    
    impl std::io::Printable {

        /**
         * Dictionnary are printable 
         */
        pub over print (self) -> void {
            print ("Dict (");
            let mut k = 0u64;
            for i, j in self._content {
                if k != 0u64 print (", ");
                match (i) {
                    Ok (x:_) => print (x, "=> ");
                }
                match (j) {
                    Ok (x:_) => print (x);
                }
                k += 1u64;
            }
            print (")");
        }
    }    
}

/**
 * Configuration encoding of an int 
 * @example: 
 * ============
 * let node : &Config = Int::new (12);
 * match node {
 *    Int (i-> i:_) => assert (i == 42);
 * }
 * ============
 */
pub class @final Int over Config {

    pub let i : i64;

    pub self (i : i64) with i = i {}

    pub self (i : i32) with i = cast!i64 (i) {}

    impl std::io::Printable {
        pub over print (self) -> void {
            print ("Int (", self.i, ")");
        }
    }
}


/**
 * Configuration encoding of a String
 * It contains a [c32] 
 * @example: 
 * ============
 * let node : &Config = Str::new ("foo");
 * match node {
 *    Int (str-> str:_) => assert (str == "foo");
 * }
 * ============
 */
pub class @final Str over Config {

    pub let str : [c32];

    pub self (str : [c32]) with str = str {}

    impl std::io::Printable {
        pub over print (self) -> void {
            print ("Str (", self.str, ")");
        }
    }
}

/**
 * Configuration encoding of a bool
 * @example: 
 * ===========
 * let node : &Config = Bool::new (true);
 * match node {
 *    Bool (b-> b:_) => assert (b == true);
 * }
 * ===========
 */
pub class @final Bool over Config {
    pub let b : bool;

    pub self (b : bool) with b = b {}

    impl std::io::Printable {
        pub over print (self)-> void {
            print ("Bool (", self.b, ")");
        }
    }
}


/**
 * Configuration encoding of a float
 * @example: 
 * ============
 * let node : &Config = Float::new (12.48)
 * match node {
 *    Float (f-> f:_) => assert (f == 12.48);
 * }
 * ============
 */
pub class @final Float over Config {
    pub let f : f64;

    pub self (f : f64) with f = f {}

    impl std::io::Printable {
        pub over print (self)-> void {
            print ("Float (", self.f, ")");
        }
    }
}

/**
 * Configuration encoding of nothing
 * @example:
 * ===========
 * let node : &Config = None::new ();
 * match node {
 *    None () => {}
 * }
 * ===========
 */
pub class @final None over Config {
    pub self () {}

    impl std::io::Printable {
        pub over print (self)-> void {
            print ("None ()");
        }
    }
}
