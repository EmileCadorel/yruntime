mod std::result;
import std::io, std::traits;
import core::typeinfo;

pub {

    /**
     * A result is the type option of Ymir
     * It can be either Succ or Err, and have a value only if it is a Succ
     */
    class @abstract Result (T) {
        pub self () {}

        impl Printable;       
    }

    /**
     * The success value when returning a result
     * Example : 
     * --------------
     * import std::io, std::errors;
     *
     * def foo () -> Option!(i32) {
     *     Some!(i32)::new (12)
     * }
     * 
     * def main () {
     *    let value = foo ();
     *    match (value) {
     *       Some!(i32) (result-> x : i32) {
     *           println ("Result of foo is : ", x);
     *       }
     *    }
     * }
     * --------------
     */
    class Ok (T) over Result!(T) {

        pub let mut result : T;

        cte if (is!(T)(alias X)) {
            pub self (mut x : T) with result = alias x {}
        } else {
            pub self (x : T) with result = x {}
        }

        pub over print (self) {
            cte if (is!(T)(X impl Printable) || isPrimitive!(T))
                print (self.result)
            else
                print ("Some!(", (self.result)::typeinfo.name, ")")
        }        
    }

    /**
     * The error value when returning nothing
     * Example : 
     * --------------
     * import std::io, std::errors;
     *
     * def foo () -> Option!(i32) {
     *     None!(i32)::new ()
     * }
     * 
     * def main () {
     *    let value = foo ();
     *    match (value) {
     *       None!(i32)() {
     *          println ("Foo didn't return any value!");
     *       }
     *    }
     * }
     * --------------
     */
    class Err (T) over Result!(T) {

        pub let msg : [c32];
        
        pub self (msg : [c32]) with msg = msg {}

        pub over print (self) {
            print ("Err (", self.msg, ")");
        }
    }
    
}
