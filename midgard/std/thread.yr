mod std.thread;
import core.io;

extern (C) pthread_join (th : u64, a : p!(p!(void)));
extern (C) pthread_exit (a : int);

public extern (C) sleep (a : int) -> void;

struct
| id : u64
 -> Thread;    
    
mod pthread (T) {
    public extern (C) pthread_create (thread : p!u64, attr : p!void, call : fn (p!T)-> p!void, data : p!T);
}

mod ThreadInfos {
    
    public static launched : [Thread]; 
    self () {
        launched = [Thread ; new 1UL];
        launched [0] = Thread {0UL};
    }
}


mod thread {
    
    def @inline spawn (T...) (foo : fn (T)-> void, data : T) -> Thread {
        return spawn (1U, foo, data.expand) [0];
    }

    def spawn (T...) (n : u32, foo : dg (T)-> void, data : T) -> [Thread] {
        let res = [Thread ; new n];
        
        for it in 0U .. n {
            let id = cast!u64 (it) + ThreadInfos::launched.len;
            let ptr = (ptr : p!(t!(dg (T) -> void, T))) {
                let (fun, data...) =  *ptr;
                fun (data.expand);
                return cast!(p!void) (null);
            };

            let alloc = [t!(dg (T) -> void, T) ; new 1U];
            alloc[0] = (foo, data.expand);
            pthread!(t!(dg (T) -> void, T))::pthread_create (&id, null, ptr, alloc.ptr);
            res [it] = Thread {id};
        }
        
        ThreadInfos::launched = ThreadInfos::launched ~ res;
        return res;
    }
    
    def spawn (T...) (n : u32, foo : fn (T)-> void, data : T) -> [Thread] {
        let res = [Thread ; new n];
        
        for it in 0U .. n {
            let id = cast!u64 (it);// + ThreadInfos::launched.len;
            let ptr = (ptr : p!(t!(fn (T) -> void, T))) {
                let (fun, data...) =  *ptr;
                fun (data.expand);
                return cast!(p!void) (null);
            };

            let alloc = [t!(fn (T) -> void, T) ; new 1U];
            alloc[0] = (foo, data.expand);
            pthread!(t!(fn (T) -> void, T))::pthread_create (&id, null, ptr, alloc.ptr);
            res [it] = Thread {id};
        }
        
        return res;
    }

    def spawn (F : FUN, FUN, T...) (n : u32, data : T) -> mut [Thread] {
        let res = [Thread ; new n];
        
        for it in 0U .. n {
            let id = cast!u64 (it) + ThreadInfos::launched.len;
            let ptr = (ptr : p!(t!(fn (T) -> void, T))) {
                let (fun, data...) =  *ptr;
                fun (data.expand);
                return cast!(p!void) (null);
            };

            let alloc = [t!(fn (T) -> void, T) ; new 1U];
            alloc[0] = (fn (T) -> void (F), data.expand);
            pthread!(t!(fn (T) -> void, T))::pthread_create (&id, null, ptr, alloc.ptr);
            res [it] = Thread {id};
        }
        
        ThreadInfos::launched = ThreadInfos::launched ~ res;
        return res;
    }
    
    def join (const th : Thread) {
        pthread_join (th.id, null);
    }

    def join (const th : [Thread]) {
        for it in th
            pthread_join (it.id, null);
    }
    
}
