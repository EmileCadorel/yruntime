mod std::conv;
import std::traits;


extern (C) def snprintf (buf : &c8, len : i32, format : &c8, ...) -> i32;
extern (C) def sprintf (buf : &c8, format : &c8, ...);

pub {
    /**
     * Transform a string of c8, c-like formated i.e. an array of c8 ending by a '\u{0}'
     * Returns: 
     * An array of c8
     */
    def to (T of [c8]) (a : &c8) -> dmut [c8] {
        if (a is null || *a == '\u{0}') return [];
        let dmut ret = ['\u{0}' ; new strlen (a)];
        let mut b = a, mut it = 0u32;
        while *b != '\u{0}' {
            ret [it] = *b;
            b = b + 1u32;
            it += 1u32;
        }
        alias ret
    }

    /**
     * Transforms an integer into a formatted array of c32, with the base 10
     * Example : 
     * --------------
     * let x = 123;
     * let z = x.to!([c32]) ();
     * assert (z == "123");
     * --------------
     */
    def if (isIntegral!T2) to (T of [c32], T2) (elem : T2) -> dmut [c32] {    
        if (elem < cast!(T2)(0)) {
            return alias ("-" ~ to!([c32]) (-elem));
        } else if (elem == cast!(T2)(0))
            return copy "0";
        
        let mut nb = elem, mut size = 0u64;
        while nb > cast!T2 (0) {
            nb /= cast!T2 (10i8);
            size += 1u64;
        }

        let mut res : [mut c32] = alias ['\u{0}' ; new size];
        let mut aux = elem;
        for it in 0u64 .. size {
            res [size - it - 1u64] = to!c32 (aux % cast!T2 (10i8));
            aux /= cast!T2 (10i8);
        }
        alias res
    }

    /**
     * Transform an integer into a c32
     * Warning: only work if /elem/ is < 10
     */
    def if (isIntegral!T2) to (T of c32, T2) (elem : T2) -> c32 {
        match (elem) {
            cast!T2 (0) => {'0'}
            cast!T2 (1) => {'1'}
            cast!T2 (2) => {'2'}
            cast!T2 (3) => {'3'}
            cast!T2 (4) => {'4'}
            cast!T2 (5) => {'5'}
            cast!T2 (6) => {'6'}
            cast!T2 (7) => {'7'}
            cast!T2 (8) => {'8'}
            cast!T2 (9) => {'9'}
            _ => '_'
        }
    }

    /**
     * Transform a array of c8 into an array of c32
     */
    def to (T of [c32]) (elem : [c8]) -> dmut [c32] {
        let dmut res = alias ['\u{0}'; new elem.len];
        for i in 0u64 .. elem.len {
            res [i] = cast!(c32) (elem [i])
        }
        alias res
    }

    
    def if (isFloating!T2) to (T of [c32], T2) (elem : T2, prec : u32) -> dmut [c32] {
        let len = cast!u32 (snprintf (cast!(&c8) (null), 0, "%.*f"s8.ptr, prec, elem));
        let dmut res = alias ['\u{0}'c8 ; new len];
        sprintf (res.ptr, "%.*f"s8.ptr, prec, elem);
        alias res.to!([c32]) ()
    }

    def if (isFloating!T2) to (T of [c32], T2) (elem : T2) -> dmut [c32] {    
        alias to!([c32]) (elem, 5u32)
    }


    def if (isFloating!T2) to (T of [c32], "e", T2) (elem : T2, prec : u32) -> dmut [c32] {
        import std::io;
        alias if elem < 0.0 {
            alias ("-" ~ to!([c32], "e") (-elem, prec))
        } else {
            let mut z = elem, mut exp = 0;
            while (z >= 10.0) {
                exp += 1;
                println (z, " ", z >= 10.0);
                z = z / 10.;
                println (z, " ", z >= 10.0);
            }
            alias alias (to!([c32]) (z) ~ "e" ~ to!([c32]) (exp))
        }
    }

    def if (isIntegral!T) to (T) (elem : [c32]) -> T {
        let mut res = T::init;
        
        let mut i = cast!i32 (elem.len) - 1;
        let mut  mul = cast!T (1);

        while i >= 0 {
            if elem [i] != ' ' {
                res += (cast!T(elem [i]) - cast!T ('0')) * mul;
                mul *= cast!T(10);
            }
            i -= 1;
        }
        
        res
    }
}
