mod std::conv;
import std::traits;
import core::array;
import std::c::string;

extern (C) def snprintf (buf : &c8, len : i32, format : &c8, ...) -> i32;
extern (C) def sprintf (buf : &c8, format : &c8, ...);

pub {
    /**
     * Transform a string of c8, c-like formated i.e. an array of c8 ending by a '\u{0}'
     * Returns: 
     * An array of c8
     */
    def to (T of [c8]) (a : &c8) -> dmut [c8] {
        if (a is null || *a == '\u{0}'c8) return [];
        let dmut ret = ['\u{0}'c8 ; new strlen (a)];
        let mut b = a, mut it = 0u32;
        while *b != '\u{0}'c8 {
            ret [it] = *b;
            b = b + 1u32;
            it += 1u32;
        }
        alias ret
    } catch {
        _ : OutOfArray =>
            []
        _ : SegFault =>
            []
    }

    /**
     * Transforms an integer into a formatted array of c32, with the base 10
     * Example : 
     * --------------
     * let x = 123;
     * let z = x.to!([c32]) ();
     * assert (z == "123");
     * --------------
     */
    def if (isIntegral!T2) to (T of [c32], T2) (elem : T2) -> dmut [c32] {
        import std::io;
        if (elem < cast!(T2)(0)) {
            return ("-" ~ to!([c32]) (-elem));
        } else if (elem == cast!(T2)(0))
            return copy "0";
        
        let mut nb = elem, mut size = 0u64;
        while nb > cast!T2 (0) {
            nb /= cast!T2 (10i8);
            size += 1u64;
        }

        let mut res : [mut c32] = ['\u{0}' ; new size];
        let mut aux = elem;
        for it in 0u64 .. size {
            res [size - it - 1u64] = to!c32 (aux % cast!T2 (10i8));
            aux /= cast!T2 (10i8);
        }
        alias res
    } catch {
        _ : OutOfArray => {
            []
        }
    }

    /**
     * Transform an integer into a c32
     * Warning: only work if /elem/ is < 10
     */
    def if (isIntegral!T2) to (T of c32, T2) (elem : T2) -> c32 {
        match (elem) {
            cast!T2 (0) => {'0'}
            cast!T2 (1) => {'1'}
            cast!T2 (2) => {'2'}
            cast!T2 (3) => {'3'}
            cast!T2 (4) => {'4'}
            cast!T2 (5) => {'5'}
            cast!T2 (6) => {'6'}
            cast!T2 (7) => {'7'}
            cast!T2 (8) => {'8'}
            cast!T2 (9) => {'9'}
            _ => '_'
        }
    }

    /**
     * Transform a array of c8 into an array of c32
     */
    def to (T of [c32]) (elem : [c8]) -> dmut [c32] {
        let dmut res = ['\u{0}'; new elem.len];
        for i in 0u64 .. elem.len {
            res [i] = cast!(c32) (elem [i])
        }
        alias res
    } catch {
        _ : OutOfArray => {
            []
        }
    }

    /**
     * Floating point value to [c32], with default format /ddd.ddd/
     * Where /d/ is a decimal value
     * Params : 
     * - prec = the number of digits after the decimal point
     */
    def if (isFloating!T2) to (T of [c32], T2) (elem : T2, prec : u32 = 6u32) -> dmut [c32] {
        import std::io
        let len = cast!u32 (snprintf (cast!(&c8) (null), 0, "%.*f"s8.ptr, prec, elem));
        let dmut res = ['\u{0}'c8 ; new len];
        sprintf (res.ptr, "%.*f"s8.ptr, prec, elem);
        alias res.to!([c32]) ()
    }

    /**
     * Floating point value to [c32], in exponant format /(-)d.ddd**e**(+\/-)ddd/
     * Where /d/ is a decimal value
     * Params : 
     * - prec = the number of digits after the decimal point
     */
    def if (isFloating!T2) to (T of [c32], "e", T2) (elem : T2, prec : u32 = 6u32) -> dmut [c32] {
        import std::io;
        let len = cast!u32 (snprintf (cast!(&c8) (null), 0, "%.*e"s8.ptr, prec, elem));
        let dmut res = alias ['\u{0}'c8 ; new len];
        sprintf (res.ptr, "%.*e"s8.ptr, prec, elem);
        alias res.to!([c32]) ()
    }

    /**
     * Floating point value to [c32], in hexadecimal format
     */
    def if (isFloating!T2) to (T of [c32], "a", T2) (elem : T2) -> dmut [c32] {
        import std::io;
        let len = cast!u32 (snprintf (cast!(&c8) (null), 0, "%a"s8.ptr, elem));
        let dmut res = alias ['\u{0}'c8 ; new len];
        sprintf (res.ptr, "%a"s8.ptr, elem);
        alias res.to!([c32]) ()
    }

    /**
     * Array of char to integral
     */
    def if (isIntegral!T) to (T) (elem : [c32]) -> T {
        let mut res = T::init;
        
        let mut i = cast!i32 (elem.len) - 1;
        let mut  mul = cast!T (1);

        while i >= 0 {
            if elem [i] != ' ' {
                res += (cast!T(elem [i]) - cast!T ('0')) * mul;
                mul *= cast!T(10);
            }
            i -= 1;
        }
        
        res
    }
}
