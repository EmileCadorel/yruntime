mod std::any;
import std::conv;
import std::io;

import core::typeinfo;

/**
 * An any type, that can store anything
 * This type is immutable, so it only can store immutable value
 */
pub class @abstract Any {

    /**
     * The class is abstract, 
     * only the successor have acces to the constructor
     */
    prot self () {}

    /**
     * Transform self into T
     * @throws: 
     *     - CastFailure: if self doen't store a value of type T
     * @templates: 
     *    - T: any type
     */
    pub def unwrap (T) (self) -> T
        throws &CastFailure
    {
        match (self) {
            s : &Some!(T) => { return s.get () }
            _ : &Any => { throw CastFailure::new ((Some!T)::typeinfo, self::typeinfo) }
        }
    }

    /**
     * An any type is printable
     */
    impl std::io::Printable;

}


/**
 * An any value, that actually store a value
 * @templates: 
 *    - T: the type of value that is stored
 * @info: the stored value is immutable
 */
pub class Some (T) over Any {

    /// The value
    let _val : T;

    /**
     * @params: 
     *    - val: a value of type T
     */
    pub self (val : T) with _val = val {}

    /**
     * @returns: the value stored
     */    
    pub def unwrap (self)-> T {
        self._val
    }
    
    /**
     * Print the value of type T to stdout
     * If T is not printable, just print its type
     */
    pub over print (self) {
        cte if (__pragma!compile ({ print (self._val); })) {
            print (self._val);
        } else {
            print (T::typeid);
        }
    }
        
}

/**
 * An any value, that stores nothing
 * It can be used as a unit type 
 */
pub class None over Any {

    /**
     * Stores nothing
     */
    pub self () {}

    /**
     * Prints it type name
     */
    pub over print (self) {
        print (typeof (self)::typeid);
    }
    
}
