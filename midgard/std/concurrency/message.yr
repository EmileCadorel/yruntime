mod std::concurrency::message;
import std::io, std::c::thread;
import std::concurrency::sync;
import core::typeinfo, core::duplication;
import core::exception, core::array;

extern (C) def pipe (streams : &(i32));

mod IOPipe (T) {
    
    pub extern (C) def _yrt_read_pipe (stream : i32, size : usize)-> T;
    
    pub extern (C) def _yrt_write_pipe (stream : i32, data : T, size : usize);
    
}

pub {

    /**
     * A pipe is a way to communicate between threads
     * Example : 
     */
    class Pipe {
        
        /** The read side of the pipe */
        let mut _read : i32 = 0;

        /** The write side of the pipe */
        let mut _write : i32 = 0;

        let mut _mutex = Mutex::new ();

        let mut _cond = Condition::new ();

        let mut _sem = Semaphore::new ();
        
        pub self () {
            let mut pipes : [mut i32] = [0, 0];
            pipe (pipes.ptr);
            {
                self._read = pipes [0];
                self._write = pipes [1];
            } catch {_ => {}}
        }

        pub def read (class T) (self) -> T {                        
            self._mutex.lock ();
            self._sem.post ();
            self._cond.wait (self._mutex);
            let ret = IOPipe!(T)::_yrt_read_pipe (self._read, sizeof T);
            self._mutex.unlock ();
            ret
        }

        pub def write (class T) (self, x : T) {            
            self._sem.wait ();
            self._mutex.lock ();
            IOPipe!(T)::_yrt_write_pipe (self._write, x, sizeof T);
            self._cond.signal ();
            self._mutex.unlock ();
        }
        
    }
    
}
