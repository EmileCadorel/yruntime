mod std::option;

import std::conv;
import std::io;
import core::typeinfo;
import core::exception;


/**
 * Option type that can store a value or not
 * This type is immutable, so it only can store immutable values
 * @example: 
 * ===============
 * def foo (x : i32) -> Option!i32 {
 *     if (x < 10) return Some::new (x);
 *     else return None!(i32)::new ();
 * }
 * 
 * let x = foo ();
 * println (x);
 * ===============
 */
pub class @abstract Option (T) {

    prot self () {}

    /**
     * @returns: the value inside the option 
     * @throws : 
     *    - CastFailure: if the option is empty
     * @params: 
     * ===============
     * let x : &Option!i32 = Some::new (12);
     * let y : &Option!i32 = None!(i32)::new ();
     * {
     *    assert (x.unwrap () == 12);
     *    println (y.unwrap ());
     * } catch {
     *    ex : &CastFailure => {
     *        println (ex);
     *    }
     * }
     * ===============
     */
    pub def unwrap (self) -> T
        throws &CastFailure {
            throw CastFailure::new (void::typeinfo, T::typeinfo);
        }

    /**
     * @returns: 
     * the value inside the option, or v, if it is empty
     * @params: 
     *    - v: the value to return if option is empty
     * @example: 
     * ===============
     * let x : &Option!i32 = Some::new (12);
     * let y : &Option!i32 = None!(i32)::new ();
     * 
     * assert (x.getOr (1) == 12);
     * assert (y.getOr (1) == 1);
     * ===============
     */
    pub def getOr (self, v : T) -> T {
        return v;
    }


    cte if (__pragma!operator ("==", T, T)) {
        
        /**
         * Compare two option values
         * @params: 
         *    - o: the other operand
         * @example: 
         * ==============
         * def foo ()-> &Option!i32 {...}
         * if (foo () == None!(i32)::new ()) {
         *    println ("foo returns nothing");
         * }
         * 
         * ==============
         */
        pub def opEquals (self, _ : &Option!T) -> bool {
            false
        }

        /**
         * Compare an option value, and a value
         * @params: 
         *    - o: the value to compare with
         * @example: 
         * ==============
         * def foo ()-> &Option!i32 {...}
         * if (foo () == 12) {
         *    println ("foo returns 12"); 
         * }
         * ==============
         */
        pub def opEquals (self, _ : T) -> bool {
            false
        }

    }

    impl std::io::Printable;
    
}

/**
 * Option value that stores a value
 * @example: 
 * =================
 * def foo ()-> Option!i32 {
 *     Some::new (42)
 * }
 * 
 * let x = foo ();
 * println (x);
 * =================
 */
pub class @final Some (T) over Option!(T) {

    let _val : T;

    /**
     * Create an option type that contains a value
     * @params: 
     *    - x: the value stored in the option type
     * @example: 
     * =============
     * let x = Some::new (42);
     * assert (x == 42);
     * =============
     */
    pub self (x: T) with _val = x {}

    /**
     * @info: Unlike Option!T, Some always contains a value, thus it never throws something
     * @returns: the value contained in the option 
     * @example: 
     * ===================
     * let x = Some::new (12);
     * assert (x.unwrap () == 12);
     * ===================
     */
    pub over unwrap (self) -> T
    {
        return self._val;
    }

    /**
     * @returns: exactly self.unwrap
     */
    pub over getOr (self, _ : T) -> T {
        return self._val;
    }

    cte if (__pragma!operator ("==", T, T)) {
        
        /**
         * Compare two option values
         * @example: 
         * ============
         * let x = Some::new (12);
         * assert (x == Some::new (12));
         * assert (x != Some::new (34));
         * ============
         */
        pub over opEquals (self, o : &Option!T) -> bool {
            match (o) {
                s : &Some!T => { s._val == self._val }
                _ => { false }
            }
        }

        /**
         * Compare an option value and a value of type T
         * @example: 
         * ==============
         * let x = Some::new (12);
         * assert (x == 12);
         * assert (x != 34);
         * ==============
         */
        pub over opEquals (self, o : T) -> bool {
            self._val == o
        }
        
    }

    impl std::io::Printable {

        /**
         * Print the value inside the option value to stdout
         * If the value is not printable, print its type name
         */
        pub over print (self) {
            cte if (__pragma!compile ({print (self._val)})) {
                print (self._val);
            } else {
                print (T::typeid);
            }
        }
        
    }
    
}

/**
 * A empty option value
 * @example: 
 * ===========
 * let x : &Option!i32 = None!(i32)::new ();
 * ===========
 */
pub class @final None (T) over Option!(T) {
    pub self () {}

    impl std::io::Printable {
        /**
         * Print the typeid of None!T to stdout
         */
        pub over print (self) {
            print ("None (", typeof (self)::typeid, ')');
        }
    }

    cte if (__pragma!compile ("==", T, T)) {

        pub over opEquals (self, _ : &Option!T) -> bool {
            match (o) {
                _ : &None!T => { true }
                _ => { false }
            }
        }

    }

    
}
