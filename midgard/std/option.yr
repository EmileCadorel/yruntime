mod std::option;
import std::io, std::traits;
import core::typeinfo;

pub {

    /**
     * A result is the type option of Ymir
     * It can be either Succ or Err, and have a value only if it is a Succ
     */
    class @abstract Option (T) {
        pub self () {}

        impl Printable;       
    }

    /**
     * The success value when returning a result
     * Example : 
     * --------------
     * import std::io, std::errors;
     *
     * def foo () -> Option!(i32) {
     *     Some!(i32)::new (12)
     * }
     * 
     * def main () {
     *    let value = foo ();
     *    match (value) {
     *       Some!(i32) (result-> x : i32) {
     *           println ("Result of foo is : ", x);
     *       }
     *    }
     * }
     * --------------
     */
    class Some (T) over Option!(T) {

        pub let result : T;

        pub self (x : T) with result = x {}        

        pub over print (self) {
            cte if (is!(T)(X impl Printable) || isPrimitive!(T))
                print (self.result)
            else
                print ("Some!(", (self.result)::typeinfo.name, ")")
        }        
    }

    /**
     * The error value when returning nothing
     * Example : 
     * --------------
     * import std::io, std::errors;
     *
     * def foo () -> Option!(i32) {
     *     None!(i32)::new ()
     * }
     * 
     * def main () {
     *    let value = foo ();
     *    match (value) {
     *       None!(i32)() {
     *          println ("Foo didn't return any value!");
     *       }
     *    }
     * }
     * --------------
     */
    class None (T) over Option!(T) {
        pub self () {}

        pub over print (self) {
            print ("None");
        }
    }

    /**
     * Encapsulate a function that might throw exception into a safe function
     * If the function throws exception return a None object
     */
    def toOption (FUN : fn (X)-> T, T, X...) (params : X) -> Option!T {
        Some::new (FUN (expand params))
    } catch {
        _ => // Catch anything
	    None!(T)::new ()
    }

    /**
     * Encapsulate a function that might throw exception into a safe function
     * If the function throws exception return a None object
     */
    def toOption (FUN : fn ()-> T, T) () -> Option!T {
        Some::new (FUN ())
    } catch {
        _ => // Catch anything
	    None!(T)::new ()
    }

    
}
